From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MidnightTale <midnighttale24@gmail.com>
Date: Sun, 20 Jul 2025 07:44:01 +0700
Subject: [PATCH] Force enabled waypoint


diff --git a/net/minecraft/commands/Commands.java b/net/minecraft/commands/Commands.java
index cd0c71504b0773ce0db4954bf5cc5d0f5ff19755..31ec545db1af243a7633b90cd9f31a0b7106c506 100644
--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -178,11 +178,11 @@ public class Commands {
     private final CommandDispatcher<CommandSourceStack> dispatcher = new CommandDispatcher<>();
 
     public Commands(Commands.CommandSelection selection, CommandBuildContext context) {
-    // Paper start - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
+        // Paper start - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
         this(selection, context, false);
     }
     public Commands(Commands.CommandSelection selection, CommandBuildContext context, final boolean modern) {
-    // Paper end - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
+        // Paper end - Brigadier API - modern minecraft overloads that do not use redirects but are copies instead
         AdvancementCommands.register(this.dispatcher);
         AttributeCommand.register(this.dispatcher, context);
         ExecuteCommand.register(this.dispatcher, context);
@@ -249,7 +249,7 @@ public class Commands {
         TitleCommand.register(this.dispatcher, context);
         ToggleInsomniaCommand.register(this.dispatcher); // atDeprecated - Register /toggleinsomnia command
         //TriggerCommand.register(this.dispatcher); // Folia - region threading - TODO later
-        //WaypointCommand.register(this.dispatcher, context); // Folia - region threading - TODO later
+        WaypointCommand.register(this.dispatcher, context); // Folia - region threading - TODO later // atDeprecated - Force enabled waypoint
         WeatherCommand.register(this.dispatcher);
         WorldBorderCommand.register(this.dispatcher);
         if (JvmProfiler.INSTANCE.isAvailable()) {
@@ -306,10 +306,10 @@ public class Commands {
                 // Modern behaviour that simply creates a full copy of the commands node.
                 // Avoids plenty of issues around registering redirects *to* these nodes from the API
                 this.dispatcher.getRoot().addChild(
-                    io.papermc.paper.command.brigadier.PaperBrigadier.copyLiteral(
-                        "minecraft:" + node.getName(),
-                        (com.mojang.brigadier.tree.LiteralCommandNode<CommandSourceStack>) node
-                    )
+                        io.papermc.paper.command.brigadier.PaperBrigadier.copyLiteral(
+                                "minecraft:" + node.getName(),
+                                (com.mojang.brigadier.tree.LiteralCommandNode<CommandSourceStack>) node
+                        )
                 );
                 continue;
             }
@@ -320,10 +320,10 @@ public class Commands {
             while (flattenedAliasTarget.getRedirect() != null) flattenedAliasTarget = flattenedAliasTarget.getRedirect();
 
             this.dispatcher.register(
-                com.mojang.brigadier.builder.LiteralArgumentBuilder.<CommandSourceStack>literal("minecraft:" + node.getName())
-                    .executes(flattenedAliasTarget.getCommand())
-                    .requires(flattenedAliasTarget.getRequirement())
-                    .redirect(flattenedAliasTarget));
+                    com.mojang.brigadier.builder.LiteralArgumentBuilder.<CommandSourceStack>literal("minecraft:" + node.getName())
+                            .executes(flattenedAliasTarget.getCommand())
+                            .requires(flattenedAliasTarget.getRequirement())
+                            .redirect(flattenedAliasTarget));
         }
         // Paper end - Brigadier Command API
         this.dispatcher.setConsumer(ExecutionCommandSource.resultConsumer());
@@ -359,10 +359,10 @@ public class Commands {
         try {
             if (contextChain != null) {
                 executeCommandInContext(
-                    commandSourceStack,
-                    executionContext -> ExecutionContext.queueInitialCommandExecution(
-                        executionContext, command, contextChain, commandSourceStack, CommandResultCallback.EMPTY
-                    )
+                        commandSourceStack,
+                        executionContext -> ExecutionContext.queueInitialCommandExecution(
+                                executionContext, command, contextChain, commandSourceStack, CommandResultCallback.EMPTY
+                        )
                 );
             }
             // Paper start
@@ -376,16 +376,16 @@ public class Commands {
 
                 for (int i = 0; i < Math.min(stackTrace.length, 3); i++) {
                     mutableComponent.append("\n\n")
-                        .append(stackTrace[i].getMethodName())
-                        .append("\n ")
-                        .append(stackTrace[i].getFileName())
-                        .append(":")
-                        .append(String.valueOf(stackTrace[i].getLineNumber()));
+                            .append(stackTrace[i].getMethodName())
+                            .append("\n ")
+                            .append(stackTrace[i].getFileName())
+                            .append(":")
+                            .append(String.valueOf(stackTrace[i].getLineNumber()));
                 }
             }
 
             commandSourceStack.sendFailure(
-                Component.translatable("command.failed").withStyle(style -> style.withHoverEvent(new HoverEvent.ShowText(mutableComponent)))
+                    Component.translatable("command.failed").withStyle(style -> style.withHoverEvent(new HoverEvent.ShowText(mutableComponent)))
             );
             if (SharedConstants.IS_RUNNING_IN_IDE) {
                 commandSourceStack.sendFailure(Component.literal(Util.describeError(var12)));
@@ -401,7 +401,7 @@ public class Commands {
         try {
             validateParseResults(parseResults);
             return ContextChain.tryFlatten(parseResults.getContext().build(command))
-                .orElseThrow(() -> CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(parseResults.getReader()));
+                    .orElseThrow(() -> CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(parseResults.getReader()));
         } catch (CommandSyntaxException var7) {
             // Paper start - Add UnknownCommandEvent
             final net.kyori.adventure.text.TextComponent.Builder builder = net.kyori.adventure.text.Component.text();
@@ -411,8 +411,8 @@ public class Commands {
             if (var7.getInput() != null && var7.getCursor() >= 0) {
                 int min = Math.min(var7.getInput().length(), var7.getCursor());
                 MutableComponent mutableComponent = Component.empty()
-                    .withStyle(ChatFormatting.GRAY)
-                    .withStyle(style -> style.withClickEvent(new ClickEvent.SuggestCommand("/" + command)));
+                        .withStyle(ChatFormatting.GRAY)
+                        .withStyle(style -> style.withClickEvent(new ClickEvent.SuggestCommand("/" + command)));
                 if (min > 10) {
                     mutableComponent.append(CommonComponents.ELLIPSIS);
                 }
@@ -427,8 +427,8 @@ public class Commands {
                 // Paper start - Add UnknownCommandEvent
                 // source.sendFailure(mutableComponent);
                 builder
-                    .append(net.kyori.adventure.text.Component.newline())
-                    .append(io.papermc.paper.adventure.PaperAdventure.asAdventure(mutableComponent));
+                        .append(net.kyori.adventure.text.Component.newline())
+                        .append(io.papermc.paper.adventure.PaperAdventure.asAdventure(mutableComponent));
             }
             org.bukkit.event.command.UnknownCommandEvent event = new org.bukkit.event.command.UnknownCommandEvent(source.getBukkitSender(), command, org.spigotmc.SpigotConfig.unknownCommandMessage.isEmpty() ? null : builder.build());
             org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
@@ -478,13 +478,13 @@ public class Commands {
 
     // Fixed pool, but with discard policy
     public static final java.util.concurrent.ExecutorService COMMAND_SENDING_POOL = new java.util.concurrent.ThreadPoolExecutor(
-        2, 2, 0, java.util.concurrent.TimeUnit.MILLISECONDS,
-        new java.util.concurrent.LinkedBlockingQueue<>(),
-        new com.google.common.util.concurrent.ThreadFactoryBuilder()
-            .setNameFormat("Paper Async Command Builder Thread Pool - %1$d")
-            .setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER))
-            .build(),
-        new java.util.concurrent.ThreadPoolExecutor.DiscardPolicy()
+            2, 2, 0, java.util.concurrent.TimeUnit.MILLISECONDS,
+            new java.util.concurrent.LinkedBlockingQueue<>(),
+            new com.google.common.util.concurrent.ThreadFactoryBuilder()
+                    .setNameFormat("Paper Async Command Builder Thread Pool - %1$d")
+                    .setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER))
+                    .build(),
+            new java.util.concurrent.ThreadPoolExecutor.DiscardPolicy()
     );
 
     private void sendAsync(ServerPlayer player, java.util.Collection<CommandNode<CommandSourceStack>> dispatcherRootChildren) {
@@ -621,8 +621,8 @@ public class Commands {
             return result.getExceptions().values().iterator().next();
         } else {
             return result.getContext().getRange().isEmpty()
-                ? CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(result.getReader())
-                : CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownArgument().createWithContext(result.getReader());
+                    ? CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownCommand().createWithContext(result.getReader())
+                    : CommandSyntaxException.BUILT_IN_EXCEPTIONS.dispatcherUnknownArgument().createWithContext(result.getReader());
         }
     }
 
@@ -670,18 +670,18 @@ public class Commands {
         CommandDispatcher<CommandSourceStack> dispatcher = new Commands(Commands.CommandSelection.ALL, commandBuildContext).getDispatcher();
         RootCommandNode<CommandSourceStack> root = dispatcher.getRoot();
         dispatcher.findAmbiguities(
-            (commandNode, commandNode1, commandNode2, collection) -> LOGGER.warn(
-                "Ambiguity between arguments {} and {} with inputs: {}", dispatcher.getPath(commandNode1), dispatcher.getPath(commandNode2), collection
-            )
+                (commandNode, commandNode1, commandNode2, collection) -> LOGGER.warn(
+                        "Ambiguity between arguments {} and {} with inputs: {}", dispatcher.getPath(commandNode1), dispatcher.getPath(commandNode2), collection
+                )
         );
         Set<ArgumentType<?>> set = ArgumentUtils.findUsedArgumentTypes(root);
         Set<ArgumentType<?>> set1 = set.stream()
-            .filter(argumentType -> !ArgumentTypeInfos.isClassRecognized(argumentType.getClass()))
-            .collect(Collectors.toSet());
+                .filter(argumentType -> !ArgumentTypeInfos.isClassRecognized(argumentType.getClass()))
+                .collect(Collectors.toSet());
         if (!set1.isEmpty()) {
             LOGGER.warn(
-                "Missing type registration for following arguments:\n {}",
-                set1.stream().map(argumentType -> "\t" + argumentType).collect(Collectors.joining(",\n"))
+                    "Missing type registration for following arguments:\n {}",
+                    set1.stream().map(argumentType -> "\t" + argumentType).collect(Collectors.joining(",\n"))
             );
             throw new IllegalStateException("Unregistered argument types");
         }
diff --git a/net/minecraft/server/waypoints/ServerWaypointManager.java b/net/minecraft/server/waypoints/ServerWaypointManager.java
index 0f8cacbb8fe55a60e2f0c98bf36c005b29f41a4b..7dc3f46c82dcdfa30438bc4016fb9fc068680341 100644
--- a/net/minecraft/server/waypoints/ServerWaypointManager.java
+++ b/net/minecraft/server/waypoints/ServerWaypointManager.java
@@ -22,7 +22,10 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
 
     @Override
     public void trackWaypoint(WaypointTransmitter waypoint) {
-        // Folia - region threading
+        // atDeprecated start - Force enabled waypoint
+        this.waypoints.add(waypoint);
+        for (ServerPlayer serverPlayer : this.players) {this.createConnection(serverPlayer, waypoint);}
+        // atDeprecated end - Force enabled waypoint
     }
 
     @Override
@@ -49,15 +52,31 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
     }
 
     public void addPlayer(ServerPlayer player) {
-        // Folia - region threading
+        // atDeprecated start - Force enabled waypoint
+        this.players.add(player);
+        for (WaypointTransmitter waypointTransmitter : this.waypoints) {this.createConnection(player, waypointTransmitter);}
+        if (player.isTransmittingWaypoint()) {this.trackWaypoint((WaypointTransmitter)player);}
+        // atDeprecated end - Force enabled waypoint
     }
 
     public void updatePlayer(ServerPlayer player) {
-        // Folia - region threading
+        // atDeprecated start - Force enabled waypoint
+        Map<WaypointTransmitter, WaypointTransmitter.Connection> map = this.connections.row(player);
+        SetView<WaypointTransmitter> set = Sets.difference(this.waypoints, map.keySet());
+        for (Entry<WaypointTransmitter, WaypointTransmitter.Connection> entry : ImmutableSet.copyOf(map.entrySet())) {this.updateConnection(player, entry.getKey(), entry.getValue());}
+        for (WaypointTransmitter waypointTransmitter : set) {this.createConnection(player, waypointTransmitter);}
+        // atDeprecated end - Force enabled waypoint
     }
 
     public void removePlayer(ServerPlayer player) {
-        // Folia - region threading
+        // atDeprecated start - Force enabled waypoint
+        this.connections.row(player).values().removeIf(connection -> {
+            connection.disconnect();
+            return true;
+        });
+        this.untrackWaypoint((WaypointTransmitter)player);
+        this.players.remove(player);
+        // atDeprecated end - Force enabled waypoint
     }
 
     public void breakAllConnections() {

diff --git a/net/minecraft/server/waypoints/ServerWaypointManager.java b/net/minecraft/server/waypoints/ServerWaypointManager.java
index 7dc3f46c82dcdfa30438bc4016fb9fc068680341..75c248892b0ff7b49a623612c0bd546c906989c8 100644
--- a/net/minecraft/server/waypoints/ServerWaypointManager.java
+++ b/net/minecraft/server/waypoints/ServerWaypointManager.java
@@ -6,6 +6,8 @@ import com.google.common.collect.Sets;
 import com.google.common.collect.Table;
 import com.google.common.collect.Tables;
 import com.google.common.collect.Sets.SetView;
+
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
@@ -16,32 +18,46 @@ import net.minecraft.world.waypoints.WaypointManager;
 import net.minecraft.world.waypoints.WaypointTransmitter;
 
 public class ServerWaypointManager implements WaypointManager<WaypointTransmitter> {
-    private final Set<WaypointTransmitter> waypoints = new HashSet<>();
-    private final Set<ServerPlayer> players = new HashSet<>();
-    private final Table<ServerPlayer, WaypointTransmitter, WaypointTransmitter.Connection> connections = HashBasedTable.create();
+    // atDeprecated start - Thread safe collections
+    private final Set<WaypointTransmitter> waypoints = Collections.synchronizedSet(new HashSet<>());
+    private final Set<ServerPlayer> players = Collections.synchronizedSet(new HashSet<>());
+    private final Table<ServerPlayer, WaypointTransmitter, WaypointTransmitter.Connection> connections = Tables.synchronizedTable(HashBasedTable.create());
+    // atDeprecated end
 
     @Override
     public void trackWaypoint(WaypointTransmitter waypoint) {
         // atDeprecated start - Force enabled waypoint
-        this.waypoints.add(waypoint);
-        for (ServerPlayer serverPlayer : this.players) {this.createConnection(serverPlayer, waypoint);}
+        synchronized (this) {
+            this.waypoints.add(waypoint);
+            for (ServerPlayer serverPlayer : this.players) {
+                this.createConnection(serverPlayer, waypoint);
+            }
+        }
         // atDeprecated end - Force enabled waypoint
     }
 
     @Override
     public void updateWaypoint(WaypointTransmitter waypoint) {
-        if (this.waypoints.contains(waypoint)) {
-            Map<ServerPlayer, WaypointTransmitter.Connection> map = Tables.transpose(this.connections).row(waypoint);
-            SetView<ServerPlayer> set = Sets.difference(this.players, map.keySet());
-
-            for (Entry<ServerPlayer, WaypointTransmitter.Connection> entry : ImmutableSet.copyOf(map.entrySet())) {
-                this.updateConnection(entry.getKey(), waypoint, entry.getValue());
-            }
+        // atDeprecated start - Thread safe
+        synchronized (this) {
+            if (this.waypoints.contains(waypoint)) {
+                Map<ServerPlayer, WaypointTransmitter.Connection> map = Tables.transpose(this.connections).row(waypoint);
+                Set<ServerPlayer> currentPlayers = ImmutableSet.copyOf(this.players);
+                SetView<ServerPlayer> set = Sets.difference(currentPlayers, map.keySet());
+
+                // Update existing connections
+                Set<Entry<ServerPlayer, WaypointTransmitter.Connection>> entries = ImmutableSet.copyOf(map.entrySet());
+                for (Entry<ServerPlayer, WaypointTransmitter.Connection> entry : entries) {
+                    this.updateConnection(entry.getKey(), waypoint, entry.getValue());
+                }
 
-            for (ServerPlayer serverPlayer : set) {
-                this.createConnection(serverPlayer, waypoint);
+                // Create new connections
+                for (ServerPlayer serverPlayer : set) {
+                    this.createConnection(serverPlayer, waypoint);
+                }
             }
         }
+        // atDeprecated end
     }
 
     @Override
@@ -53,41 +69,65 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
 
     public void addPlayer(ServerPlayer player) {
         // atDeprecated start - Force enabled waypoint
-        this.players.add(player);
-        for (WaypointTransmitter waypointTransmitter : this.waypoints) {this.createConnection(player, waypointTransmitter);}
-        if (player.isTransmittingWaypoint()) {this.trackWaypoint((WaypointTransmitter)player);}
+        synchronized (this) {
+            this.players.add(player);
+            for (WaypointTransmitter waypointTransmitter : this.waypoints) {
+                this.createConnection(player, waypointTransmitter);
+            }
+            if (player.isTransmittingWaypoint()) {
+                this.trackWaypoint((WaypointTransmitter)player);
+            }
+        }
         // atDeprecated end - Force enabled waypoint
     }
 
     public void updatePlayer(ServerPlayer player) {
         // atDeprecated start - Force enabled waypoint
-        Map<WaypointTransmitter, WaypointTransmitter.Connection> map = this.connections.row(player);
-        SetView<WaypointTransmitter> set = Sets.difference(this.waypoints, map.keySet());
-        for (Entry<WaypointTransmitter, WaypointTransmitter.Connection> entry : ImmutableSet.copyOf(map.entrySet())) {this.updateConnection(player, entry.getKey(), entry.getValue());}
-        for (WaypointTransmitter waypointTransmitter : set) {this.createConnection(player, waypointTransmitter);}
+        synchronized (this) {
+            Map<WaypointTransmitter, WaypointTransmitter.Connection> map = this.connections.row(player);
+            SetView<WaypointTransmitter> set = Sets.difference(this.waypoints, map.keySet());
+            for (Entry<WaypointTransmitter, WaypointTransmitter.Connection> entry : ImmutableSet.copyOf(map.entrySet())) {
+                this.updateConnection(player, entry.getKey(), entry.getValue());
+            }
+            for (WaypointTransmitter waypointTransmitter : ImmutableSet.copyOf(set)) {
+                this.createConnection(player, waypointTransmitter);
+            }
+        }
         // atDeprecated end - Force enabled waypoint
     }
 
     public void removePlayer(ServerPlayer player) {
         // atDeprecated start - Force enabled waypoint
-        this.connections.row(player).values().removeIf(connection -> {
-            connection.disconnect();
-            return true;
-        });
-        this.untrackWaypoint((WaypointTransmitter)player);
-        this.players.remove(player);
+        synchronized (this) {
+            this.connections.row(player).values().removeIf(connection -> {
+                connection.disconnect();
+                return true;
+            });
+            this.untrackWaypoint((WaypointTransmitter)player);
+            this.players.remove(player);
+        }
         // atDeprecated end - Force enabled waypoint
     }
 
     public void breakAllConnections() {
-        this.connections.values().forEach(WaypointTransmitter.Connection::disconnect);
-        this.connections.clear();
+        // atDeprecated start - Thread safe
+        synchronized (this) {
+            Set<WaypointTransmitter.Connection> currentConnections = ImmutableSet.copyOf(this.connections.values());
+            currentConnections.forEach(WaypointTransmitter.Connection::disconnect);
+            this.connections.clear();
+        }
+        // atDeprecated end
     }
 
     public void remakeConnections(WaypointTransmitter waypoint) {
-        for (ServerPlayer serverPlayer : this.players) {
-            this.createConnection(serverPlayer, waypoint);
+        // atDeprecated start - Thread safe
+        synchronized (this) {
+            Set<ServerPlayer> currentPlayers = ImmutableSet.copyOf(this.players);
+            for (ServerPlayer serverPlayer : currentPlayers) {
+                this.createConnection(serverPlayer, waypoint);
+            }
         }
+        // atDeprecated end
     }
 
     public Set<WaypointTransmitter> transmitters() {
@@ -132,3 +172,4 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
         }
     }
 }
+
