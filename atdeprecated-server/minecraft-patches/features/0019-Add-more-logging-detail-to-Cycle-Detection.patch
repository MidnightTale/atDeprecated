From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MidnightTale <midnighttale24@gmail.com>
Date: Sat, 26 Jul 2025 18:08:18 +0700
Subject: [PATCH] Add more logging detail to Cycle Detection


diff --git a/net/minecraft/util/Graph.java b/net/minecraft/util/Graph.java
index 698420895bb556fe28518b97ec9799adda25ada4..ff1b619fa3da44cba0ada0048634e82022150d1b 100644
--- a/net/minecraft/util/Graph.java
+++ b/net/minecraft/util/Graph.java
@@ -9,24 +9,30 @@ public final class Graph {
     private Graph() {
     }
 
-    public static <T> boolean depthFirstSearch(Map<T, Set<T>> graph, Set<T> nonCyclicalNodes, Set<T> pathSet, Consumer<T> onNonCyclicalNodeFound, T currentNode) {
+    public static <T> java.util.List<T> depthFirstSearch(Map<T, Set<T>> graph, Set<T> nonCyclicalNodes, Set<T> pathSet, Consumer<T> onNonCyclicalNodeFound, T currentNode) {
         if (nonCyclicalNodes.contains(currentNode)) {
-            return false;
+            return java.util.Collections.emptyList();
         } else if (pathSet.contains(currentNode)) {
-            return true;
+            return java.util.List.of(currentNode);
         } else {
             pathSet.add(currentNode);
 
             for (T object : graph.getOrDefault(currentNode, ImmutableSet.of())) {
-                if (depthFirstSearch(graph, nonCyclicalNodes, pathSet, onNonCyclicalNodeFound, object)) {
-                    return true;
+                java.util.List<T> cycle = depthFirstSearch(graph, nonCyclicalNodes, pathSet, onNonCyclicalNodeFound, object);
+                if (!cycle.isEmpty()) {
+                    if (cycle.get(0).equals(currentNode)) {
+                        return cycle;
+                    }
+                    java.util.List<T> ret = new java.util.ArrayList<>(cycle);
+                    ret.add(0, currentNode);
+                    return ret;
                 }
             }
 
             pathSet.remove(currentNode);
             nonCyclicalNodes.add(currentNode);
             onNonCyclicalNodeFound.accept(currentNode);
-            return false;
+            return java.util.Collections.emptyList();
         }
     }
 }
diff --git a/net/minecraft/world/level/biome/FeatureSorter.java b/net/minecraft/world/level/biome/FeatureSorter.java
index 8b81b5e010b974a0319ef47a897814e30e1e9e63..b5cd0f2de9af9ba9830fd57f29fe0889b7663702 100644
--- a/net/minecraft/world/level/biome/FeatureSorter.java
+++ b/net/minecraft/world/level/biome/FeatureSorter.java
@@ -67,33 +67,29 @@ public class FeatureSorter {
                 throw new IllegalStateException("You somehow broke the universe; DFS bork (iteration finished with non-empty in-progress vertex set");
             }
 
-            if (!set1.contains(featureData) && Graph.depthFirstSearch(map1, set1, set2, list::add, featureData)) {
-                if (!notRecursiveFlag) {
-                    throw new IllegalStateException("Feature order cycle found");
-                }
-
-                List<T> list2 = new ArrayList<>(featureSetSources);
-
-                int size;
-                do {
-                    size = list2.size();
-                    ListIterator<T> listIterator = list2.listIterator();
-
-                    while (listIterator.hasNext()) {
-                        T object1 = listIterator.next();
-                        listIterator.remove();
-
-                        try {
-                            buildFeaturesPerStep(list2, toFeatueSetFunction, false);
-                        } catch (IllegalStateException var18) {
-                            continue;
+            java.util.List<FeatureData> cycle = Graph.depthFirstSearch(map1, set1, set2, list::add, featureData);
+            if (!cycle.isEmpty()) {
+                if (notRecursiveFlag) {
+                    List<T> list2 = new ArrayList<>(featureSetSources);
+                    int i1;
+                    do {
+                        i1 = list2.size();
+                        ListIterator<T> listiterator = list2.listIterator();
+                        while (listiterator.hasNext()) {
+                            T t0 = listiterator.next();
+                            listiterator.remove();
+                            try {
+                                buildFeaturesPerStep(list2, toFeatueSetFunction, false);
+                            } catch (IllegalStateException illegalstateexception) {
+                                continue;
+                            }
+                            listiterator.add(t0);
                         }
-
-                        listIterator.add(object1);
-                    }
-                } while (size != list2.size());
-
-                throw new IllegalStateException("Feature order cycle found, involved sources: " + list2);
+                    } while (i1 != list2.size());
+                    throw new IllegalStateException("Feature order cycle found, involved sources: " + list2);
+                }
+                final java.util.stream.Stream<String> cycleStream = cycle.stream().map(d -> d.feature).map(net.minecraft.data.worldgen.placement.PlacementUtils::getKey).filter(java.util.Optional::isPresent).map(java.util.Optional::get).map(key -> key.location().toString());
+                throw new IllegalStateException("Feature order cycle found, cycle includes: " + cycleStream.collect(Collectors.joining(", ")));
             }
         }
 
